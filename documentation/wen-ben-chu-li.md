# 文本处理

#### 字符串

* 单引号
* 双引号
* heredoc 语法结构
* nowdoc 语法结构

> 单引号和双引号的区别 ?
>
> 双引号到底解析那些字符 ?
>
> * 当字符串使用双引号或heredoc结构定义时 , 其中的变量将会被解析 . 
> * `\n,\r,\t,\v,\e,\f,\\,\$,\"` - 会被解析的转义字符 .
> * `\[0-7]{1,3}` - 符合该正则表达式序列的是一个以八进制方式来表达的字符 . 
> * `\x[0-9A-Fa-f]{1,2}` - 符合该正则表达式序列的是一个以十六进制方式来表达的字符 .

#### 字符串结构体

> 底层C语言怎么表示PHP字符串 ?

```c
struck {
    char *val;
    int len;
} str;
```

C语言中是没有字符串的 , 但是它有字符指针 , 也就是结构体里的`char *val;`元素 , 而且还存了一个int型号的字符长度 , 表示PHP里当前字符串的长度 .

* 通过字符指针, 可以把PHP的字符串看成是一个字节组成的数组 , 所以可以通过\[\]或者{}访问PHP字符串的某个字符 ;
* 字符串长度可以达到2G内存 , 也就是字符串变量可以赋值达到2G , 几乎等于没有限制 ;
* 常见的字符串函数都是单字节处理方式 , 当然PHP里也有多字节字符串扩展库 , 如 , mb\_sting . 
* PHP字符串是二进制安全的 , 通过结构体的int len可以知道字符串的长度 , 字符串的元素的开始结束位置 , 而C语言中的char是通过\0获知字符串结束位置的 , 在转为为二进时遇到了\0就会被截断 , PHP通过len , 可以说PHP字符串是二进制安全的 , C语言是不安全的 . 

**思考**

下面代码的输出结果 ?

```php
<?php

$str = 'a';
$str[100] = 'e';
echo $str;
```

查看输出结果 , 得到结论 :

用超出字符串长度的下标写入将会拉长该字符串并以空格填充 .

**字符串存取总结**

* string中的字符可以通过一个从0开始的下标 , 用类似array结构中的方括号包含对应的数字来访问和修改 , 比如$str\[24\] . 
* 也可以用花括号访问 , 比如$str{22} . 
* 用超出字符串长度的下标写入将会拉长该字符串并以空格填充 .
* 非整数类型下标会被转换成整数 , 非法下标会产生一个E\_NOTICE界别的错误 . 

#### 字符串的串行化

串行化的目的就是把其他不方便存储的类型保存在文件,数据库中 , 如数组 , 对象等 .

* 函数serialize\(\) - 侧重转换对象 , 在unserialize\(\)时候会直接转换为对象 , 使用其中的方法 , 不用实例化 . 
* 函数json\_encode\(\) - 虽然返回的也可以是一个对象 , 但它是一个json对象 . 而反序列化返回的是一个存储时类的新对象 . 
* 函数var\_export\($items, true\) - 输出一个PHP格式的数组字符串 , 第二个参数为true返回 , 可以赋值给变量 , 不写则打印 . 

**var\_export应用实例**

可以当做文件缓存使用 .

```php
<?php

$arr = [1,2,3,4,5,6];
$str = var_export($arr, true);
$str = '<?php return ' . $str . ';';
file_put_contents('xxx', $str);

# 其他文件
$var = include 'xxx';
var_dump($var);
```

#### PHP的字符编码

**位 , 字节 , 字符**

* **位\(bit b\)** - 二进制中的一位 , 是二进制最小信息单位 , 要么是1,要么是0.
* **字节\(Byte B\)** - 计算机中计量存储容量的一种计量单位 , 比如 , 8个位是一个字节 .
* **字符\(Character\)** - 计算机中使用的字母,数字,很自和符号等 .

**字符集和字符编码**

* **字符集\(charset\)** - 是一个系统支持的所有抽象字符的集合
* **字符编码\(Character Encoding\)** - 是一套法则 , 使字符集与计算机之间建立对应关系 , 就是将字符转换为计算机可以接收的数字代码 . **就是以二进制的数字来对应字符集的字符** .

**常见的字符编码**

**ASCII** - ASCII只是用了一个字节表示编码 , 使用前7位\(bits\)表示一个字符 , 2^7共128个字符 .0-127 .

**ISO-8859-1** - 是ASCII的扩展的一种 , 兼容ASCII编码 , 扩展了第八位 , 也就是128-255的字符 , 存储了欧洲一些国家语言中使用到的字符 , 例如Laitin1编码 , 也是ISO-8859-1的别名 .

**GB 2312** - 简体中文

收录了6762个汉字和682个非汉字图形字符 . 后来在其基础之上添加了一些生僻的汉字 , 就是GBK编码 . 也是兼容GB 2312 .

GB 2312是一个汉字用两个字节表示 , 两个字节也就意味着可以表示256\*256种不同的符号 . 当然实际上并没有那么多 , 实际大概有8000多个 .

为了兼容ASCII , 前127位的就都没用 , 再加上一些控制功能码 , 也就少了很多 .

最后 , 使用到的是一个94\*94的区和位的方阵 , 每个区有94个位 , 由01-94的汉字字符集 , 成为**区位码** , 也就是一个汉字的区号和位号组成了区位码 , 前面的高两位是区号 , 后边的低两位为位号 , 比如 , 通过区位码1703寻找 , 可以找到"保"字 , 也就是说它在第17区 , 第三位 .

还有一个国标码的概念 , 前面提到的区位码是从01开始的 , 但是也是之前去掉了一些ASCII占用的控制符等开始的 , 国标码就是通过换算得到的从ASCII之后开始的编码 .

**国标码 = 区位码+20H\(16进制\)**

国标码并不是计算机内真正存储的二进制编码 . 

真正的汉字在计算机内保存的 , 也就是汉字字符和二进制之间的对应关系 , 叫机内码 . 

**机内码 = 国标码 + 80H\(16进制\)**

**BIG5** - 台湾繁体中文内码

**Unicode**

总数已经超过65535 , 所以2个字节的数字就不够用了 . 为了表达任意语言字符 , 扩展到了使用4个字节的数字来表达这些不同国家的字符 , 数字 , 符号等 .

常见的UTF-32/UTF-16/UTF-8是三种字符编码方案 . 这就是Unicode和utf8之间的关系 .

