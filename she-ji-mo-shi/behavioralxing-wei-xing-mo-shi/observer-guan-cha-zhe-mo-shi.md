# Observer - 观察者模式

#### 模式描述

观察者模式实现了对对象的发布/订阅行为 , 每当 "主题" 对象更改其状态时 , 将通知附加的 "观察者" . 它用于缩短耦合对象的数量 , 而使用松散耦合 . 例如 , 观察消息队列系统以显示 GUI 中作业的进度 . 

观察者模式的一个比较好理解的类比就是博客订阅。被订阅的博客是主体，而订阅了该博客的用户是客体，或者称为观察者。当主体发生改变，比如主体有新的文章，那么就需要通知所有的客体，使得客体能得到通知并更新订阅的内容。而客体是通过一种“注册订阅”的功能来告诉主体它想当一个观察者，意思就是告诉主体，“我对你的数据感兴趣，一有变化请通知我”。当然，客体也可以“取消订阅”，然后不再获得主体的通知。关于客体的一切，主体只知道客体实现了某个接口。主体不需要知道客体的具体类是谁、做了什么。任何时候都可以增加新的客体，而且主体不会受到影响。因为它们两者是松耦合的。要做到主体和客体之间相互独立地被复用，可以采用观察者模式。观察者就定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

**总结**

> 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。
>
> 将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。
>
> 观察者模式所做的工作其实就是在接触耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。





