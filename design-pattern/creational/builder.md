# 生成器模式 - Builder

[https://zh.wikipedia.org/wiki/生成器模式](https://zh.wikipedia.org/wiki/生成器模式)

#### 描述

生成器模式 , 也叫建造模式 , 是一种对象构建模式 . 它可以将复杂对象的建造过程抽象出来\(抽象类别\) , 使这个抽象过程的不同实现方法可以构造出不同表现\(属性\)的对象 .

有时候 , 如果生成器对生成的内容有更好的描述 , 则此接口可能是具有默认方法的抽象类\(也叫适配器\) . 如果对象具有复杂的继承树 , 则对于生成器也具有复杂的继承树是合乎逻辑的 .

> 建造者通常有一个「[流式接口](https://zh.wikipedia.org/wiki/流式接口)」, 例如 PHPUnit 模拟生成器 .

#### 使用

假设我们有个生产车的工厂 , 可以制造各种车 , 比如自行车、汽车、卡车等等 , 如果每辆车都是从头到尾按部就班地造 , 必然效率低下 .

我们可以试着将车的组装和零部件生产分离开来 : 让一个类似“导演”的角色负责车子组装 , 而具体造什么样的车需要什么样的零部件让具体的“构造者”去实现 , “导演”知道什么样的车怎么造 , 需要的零部件则让“构造者”去建造 , 何时完成由“导演”来控制并最终返回给客户端 .

在以下情况使用生成器模式 :

* 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时 ; 
* 当构造过程必须允许被构造的对象有不同的表示时 ; 

协作流程 : 

客户创建Director对象 , 并用它所想要的Builder对象进行配置 . 

* 一旦产品部件被生成 , Director类就会通知生成器
* 生成器处理Director类的请求 , 并将部件添加到该产品中
* 客户从生成器中检索产品

#### 注意

装配和构造接口

* 生成器逐步的构造它们的产品 . 因此**生成器界面必须足够普遍 , **以便为各种类型的具体生成器构造产品 . 

没有抽象类

* 通常情况下 , 由具体生成器生成的产品 , 它们的表示相差是如此之大以至于给不同的产品以公共父类没有太大意思 . 

在生成器中预设的方法为空

* 定义为空方法可以使客户只重定义他们所感兴趣的操作 . 

#### 效果

* 它使你可以改变一个产品的内部表示
* 它将构造代码和表示代码分开
* 它使你可对构造过程进行更精细的控制

#### 总结

建造者模式和抽象工厂模式很像 . 总体上 , 建造者模式仅仅只比抽象工厂模式多了一个“导演类”的角色 . 与抽象工厂模式相比 , 建造者模式一般用来创建更为复杂的对象 , 因为对象的创建过程更为复杂 , 因此将对象的创建过程独立出来组成一个新的类 —— 导演类 . 也就是说 , 抽像工厂模式是将对象的全部创建过程封装在工厂类中 , 由工厂类向客户端提供最终的产品 ; 而建造者模式中 , 建造者类一般只提供产品类中各个组件的建造 , 而将完整建造过程交付给导演类 . 由导演类负责将各个组件按照特定的规则组建为产品 , 然后将组建好的产品交付给客户端 . 

#### 结构

* **Builder** -为创建一个Product对象的各个部件指定接口
* **ConcreateBuilder** - 实现Builder的接口以构造和装配该产品的各个部件 . 定义并明确它所创建的表示 . 提供一个检索产品的接口 . 
* **Director** - 构造一个使用Builder接口的对象 . 
* **Product** - 表示被构造的复杂对象 . ConcreateBuilder创建该产品的内部表示并定义它的装配过程 . 包含定义组成部件的类 , 包括将这些部件装配成最终产品的接口 . 

![](/assets/builder.png)

