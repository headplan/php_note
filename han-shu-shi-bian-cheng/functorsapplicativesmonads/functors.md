# Functors

在直接讲Monad之前 , 让我们从头开始 . 为了理解Monad是什么 , 我们需要引入一些相关的概念 . 首先 ,第一个就是Functors .

说的复杂一点 , 在函数式编程中 , 用Functors来描述函数对象 , 但和我们平常理解的函数对象的概念是完全不同的 . 在PHP中 , 具有\_\_invoke方法的对象 , 就是一个这样的函数对象 .

然而 , 在函数式编程中 , Functors是从类别理论的数学领域中获取和改编的概念 . 其细节对这里就不深究了 , 只要了解一个Functors就是一个模式 , 让我们可以将函数映射到上下文中 , 并且包含的一个或多个值 . 另外 , 为了使定义尽可能完整，Functors必须遵守一些规则或者说约定 , 这些我们将在后面进行描述和验证 .

我们已经在集合中多次使用了Map , 事实上我们已经接触了Functors . 但是 , 如果没记错的话 , 我们也自定义了一个我们的方法函数 , 以相同的方式将函数应用于Maybe中包含的值 . 其原因是 , "Functors" 可以被看作是一种将函数应用于所包含的值的容器 .

在某种意义上 , 实现以下接口的任何类都可以称为Functor :

```php
<?php
interface Functor
{
    public function map(callable $f): Functor;
}
```

然而 , 这样解释可能有点笼统 . 比如 ,  一个简单的PHP数组也是一个Functor\(因为array\_map函数存在\) , 就像任何实现 "Traversable\(遍历\)" 接口的东西一样 , 只要你使用 "functional-php" 库及其 "map" 函数 , 也是一个道理 .

为什么这么简单的想法如此小题大做 ? 因为, 尽管这个概念本身很简单, 但它允许我们对发生在不同的情景中的事情进行推理 , 并可能帮助理解和重构代码 . 

此外, "map" 函数可以比盲目应用给定的 "回调" 类型更重要, 就像使用 "array" 的情况一样 . 如果您还记得我们的 "Maybe" 类型的实现, 在一个值 "无" 的情况下, "map" 函数简单地保持返回 "无" 值, 以便能够更简单地管理 null 值 . 

我们也可以想象在我们的Functor中有更复杂的数据结构 , 比如树 , 其中赋予Map函数的Functor被应用于所有节点 . 

Functors允许我们共享一个通用接口 , 我们的映射方法或函数 , 以便在隐藏实现的复杂性的同时对各种数据类型执行类似的操作 . 与函数式编程一样 , 认知负担减少 , 因为您不具有相同操作的多个名称 . 例如"apply", "perform", "walk" 等函数和方法名称经常被看作是描述相同的事情 . 

